# Agent Guidelines for dashboard/

These instructions apply only to the dashboard/ subtree of XControl. They augment
the root-level AGENTS.md with stricter rules specifically for the Next.js UI codebase.

The dashboard is a Next.js App Router application implemented in TypeScript with
Tailwind CSS, Zustand state management, and Vitest/Playwright tests.

This document defines the architectural rules that all contributors â€” human or AI agents â€”
must follow when modifying any code under dashboard/.

## ğŸ“Œ 1. State Management Rules (Zustand-Only Architecture)

Global state inconsistencies are the primary source of UI bugs and unpredictability.
To eliminate this entire class of issues, the dashboard enforces:

âœ… Zustand is the ONLY allowed global/shared state mechanism.
âŒ React Context Providers are disallowed for global state.

This includes:

No createContext, useContext, or <Context.Provider> for app-level data
(auth/session/user/theme/language/insight/workbench/shared config).
No â€œhybridâ€ patterns where Zustand data is mirrored inside a Provider.
No component-level useState / useEffect holding cross-component state.

âœ” All shared state MUST live inside Zustand slices

Each slice must:
Export a useXStore(selector) function.
Expose clear state + actions.
Remain serializable for hydration when needed.
Keep the shape stable and predictable.

âœ” Recommended slice structure (pattern)
/dashboard/src/state/
  user.ts            â†’ auth/session
  theme.ts           â†’ light/dark/system
  language.ts        â†’ i18n
  insight.ts         â†’ insight editor / workbench
  runtime.ts         â†’ runtime service config (hydrated from YAML)


Slices should follow this format:

export const useUserStore = create<UserState>()(
  persist(
    (set, get) => ({
      user: null,
      isLoading: false,
      setUser: (u) => set({ user: u }),
      clearUser: () => set({ user: null }),
    }),
    { name: 'user' }
  )
)

ğŸ“Œ 2. URL-Synchronized State Must Live in Zustand

Features such as:

insight editor / workbench state
encoded shareable links
URL â†’ state hydration
state â†’ URL serialization
MUST be handled inside the Zustand slice not in the component tree.

âŒ Forbidden

Components containing URL parsing logic
Components reading searchParams and storing them in local state
Effects that attempt to â€œmirrorâ€ global data into component-local state
âœ” Mandatory

Zustand slices must expose helpers such as:

hydrateFromURL(searchParams: URLSearchParams)
syncToURL(router: AppRouterInstance)
serialize(): string


This keeps the UI stateless and predictable.

ğŸ“Œ 3. Component-level State Rules

Local UI state (modal open, hover, controlled inputs) is allowed:

Allowed:

useState for purely local visuals
useEffect for browser-only side effects
useRef for DOM details

Not allowed:

useState for data needed across pages/components
useEffect that propagates shared state upward

When unsure:
If two components could ever read it â†’ it belongs in Zustand.

ğŸ“Œ 4. File Structure & Code Conventions
Directory structure

Maintain component, state, and utility layout:

src/
  app/               â†’ routes (App Router)
  components/        â†’ presentational components
  state/             â†’ Zustand slices
  hooks/             â†’ reusable UI hooks
  lib/               â†’ shared utilities (non-state)
  config/            â†’ runtime-service-config.yaml and loaders

Code style

ESLint + Prettier formatting

2-space indentation

Single quotes

No unused exports

No default exports for slices or large utilities
(Easier for static analysis + tree shaking)

ğŸ“Œ 5. Environment, Config & Runtime Rules
Declarative configuration only

Do not add browser-only environment variables.

All new runtime config fields must go into:

dashboard/config/runtime-service-config.yaml


And be hydrated by a Zustand slice (e.g., runtime.ts).

ğŸ“Œ 6. AI Agent (Codex/GPT) Rules â€” Strict Mode

Because the dashboard often uses AI to refactor/upgrade code, the following constraints
apply specifically to code generated by agents:

ğŸš« Agents MUST NOT:

Generate any form of React Provider for global state

Introduce hybrid Context+Zustand patterns

Use component-level state for shared logic

Use browser APIs (window, localStorage) in server-compatible modules

Change directory structure without explicit instruction

Generate environment variables not reflected in runtime-service-config.yaml

âœ… Agents MUST:

Implement all shared logic as Zustand slices

Keep slices serializable and deterministic

Produce code compatible with Next.js App Router (SSR + CSR safe)

Follow ESLint and existing style conventions

Ensure newly generated slices include proper actions/selectors

Prefer pure functions and stable keys for Zustand persist middlewares

ğŸ“Œ 7. Testing Requirements

Contributors must run:

yarn --cwd dashboard lint
yarn --cwd dashboard test
yarn --cwd dashboard test:e2e


Slices that handle URL hydration must include unit tests verifying:

URL â†’ state correctness

state â†’ URL correctness

shareable link determinism

Insight-related state should always include at least minimal test coverage.

ğŸ“Œ 8. Summary of Key Constraints (TL;DR)
ğŸš« Forbidden

React Context for shared/global state

useState/useEffect for cross-component data

Ad-hoc URL parsing inside components

âœ” Required
Zustand-only global state
URL hydration inside Zustand slices
Declarative runtime config (YAML â†’ slice)
AI agents must follow deterministic slice architecture
